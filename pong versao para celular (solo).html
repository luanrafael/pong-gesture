<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pong Gesture</title>

    <script src="../js/hammer.min.js"></script>

    <!-- Basic styling, centering the canvas -->    
    <style>
	html, body {
		overflow: hidden;
		margin: 0;
	}
		
	#hit {
		position: absolute;
	}
    </style>
</head>
<body>
    <div>
        <div>
            <div id="hit" style="background: #42d692; width: 150px; height: 150px;">
				<canvas id="canvas" width="150" height="112"></canvas>
			</div>
        </div>
    </div>

    <script>
		
    var

    LARGURA  = window.innerWidth,
    ALTURA   = window.innerHeight,
    LARGURA_JOGADOR = LARGURA / 70,
    ALTURA_JOGADOR = ALTURA / 6,
    POS_INI_Y = (ALTURA - ALTURA_JOGADOR) / 2,
    DIAMETRO_BOLA = window.innerWidth / (window.innerWidth < 600 ? 30 : 70),
    canvas,
    ctx,
	
	ai = {
		x: LARGURA - LARGURA_JOGADOR,
		y: null,
		pontos: 0, 
		largura:  LARGURA_JOGADOR,
		altura: ALTURA_JOGADOR,

		/**
		 * Update the position depending on the ball position
		 */
		atualizar: function() {
			// calculate ideal position
			var desty = bola.y - (this.altura - bola.diametro) * 0.5;
			// ease the movement towards the ideal position
			this.y += (desty - this.y) * 0.1;
			// keep the paddle inside of the canvas
			this.y = Math.max(Math.min(this.y, ALTURA - this.altura), 0);
		},

		/**
		 * Draw the ai paddle to the canvas
		 */
		desenhar: function() {
			ctx.fillRect(this.x, this.y, this.largura, this.altura);
			ctx.fillRect(this.x, this.y, this.largura, this.altura);
			ctx.font = "26px Helvetica";
			ctx.fillText(this.pontos, LARGURA  / 2 + 20, 20);
		}
	},
	

    //Criação do objeto Jogador. Onde respectivamente os parâmetros são referentes a posição X, Y, posição X de onde ficará o valores da pontuação, e a cor para que ele possa se mover na tela.
    Jogador = function(X, Y, pX, corParaMover){
        return {
            x: X,
            y: Y,
            pontos: 0,
            cor: corParaMover,
            largura:  LARGURA_JOGADOR,
            altura: ALTURA_JOGADOR,

            //método responsável para atualizar a posição Y da paleta conforme o jogador move a cor.
            atualizar: function() {
                //define limites para que o meu jogador não saia dos limites da tela
                this.y = Math.max(Math.min(this.y, ALTURA - this.altura), 0);
            },

            //método responsável por atualizar o desenho da paleta conforme o jogador move a cor.
            desenhar: function() {
                //desenha a paleta com os parâmetros passados
                ctx.fillRect(this.x, this.y, this.largura, this.altura);
                //define a fonte que será usada para escrever a pontuação do jogador
                ctx.font = "26px Helvetica";
                //define o que será escrito na tela, e qual será a posição X e depois a Y
                ctx.fillText(this.pontos, pX, 20);
            }           
        };
    };
	
    jogador1 = new Jogador(0, POS_INI_Y, LARGURA  / 2 - 35, 'yellow');


    //objeto bola com a posição X e a posição Y inicial, Velocidade e a diametro
    Bola = function(Diametro){
        return {
            x: 0,
            y: 0,
            vel: null,
            diametro: Diametro,
            velocidade: 12,

            configurar: function(lado) {
                // sorteando uma posição aleatória para criar a nossa bola para colocar na posição Y
                var r = Math.random();
                this.x = lado === 1 ? jogador1.x + jogador1.largura : ai.x - this.diametro;
                this.y = (ALTURA - this.diametro) * r;
                // calcular o ângulo, maior ângulo / inferior no eixo-y mais íngreme
                var phi = 0.1 * Math.PI * (1 - 2 * r);
                // calculando a velocidade que a bola irá se mover
                this.vel = {
                    x: lado * this.velocidade * Math.cos(phi),
                    y: this.velocidade * Math.sin(phi)
                }
            },

            atualizar: function() {
                // atualiza a posição com a velocidade atual
                this.x += this.vel.x;
                this.y += this.vel.y;
                //checando se  sai dos limites da tela na posição Y
                if (0 > this.y || this.y + this.diametro > ALTURA) {
                    // calculate and add the right offset, i.e. how far
                    // inside of the canvas the bola is
                    var offset = this.vel.y < 0 ? 0 - this.y : ALTURA - (this.y + this.diametro);
                    this.y += 2 * offset;
                    // mirror the y velocity
                    this.vel.y *= -1;
                }
                // helper function to check intesectiont between two
                // axis aligned bounding boxex (AABB)
                var AABBIntersect = function(ax, ay, aw, ah, bx, by, bw, bh) {
                    return ax < bx+bw && ay < by+bh && bx < ax+aw && by < ay+ah;
                };

                // detectando colisão
                var pdle = this.vel.x < 0 ? jogador1 : ai;
                if (AABBIntersect(pdle.x, pdle.y, pdle.largura, pdle.altura,
                        this.x, this.y, this.diametro, this.diametro)
                ) { 
                    // set the x position and calculate reflection angle
                    this.x = pdle === jogador1 ? jogador1.x + jogador1.largura : ai.x - this.diametro;
                    var n = (this.y + this.diametro - pdle.y) / (pdle.altura + this.diametro);
                    var phi = 0.25 * Math.PI * (2 * n - 1); // pi/4 = 45
                    // calculate smash value and update velocity
                    var batida = Math.abs(phi) > 0.2 * Math.PI ? 1.5 : 1;
                    this.vel.x = batida * (pdle === jogador1 ? 1 : -1) * this.velocidade * Math.cos(phi);
                    this.vel.y = batida * this.velocidade * Math.sin(phi);
                }

                // coloca a bola novamente no campo na posição X que ela saiu.
                if (0 > this.x + this.diametro || this.x > LARGURA) {
                    if (pdle === jogador1)
                        ai.pontos += 1;
                    else
                        jogador1.pontos += 1;
                    this.configurar(pdle === jogador1 ? 1 : -1);
                }
            },

            desenhar: function() {
                ctx.fillRect(this.x, this.y, this.diametro, this.diametro);
            }            
        };
    };

    bola = new Bola(DIAMETRO_BOLA);

    function main(){
        canvas = document.createElement("canvas");
        canvas.width = LARGURA;
        canvas.height = ALTURA;
        ctx = canvas.getContext("2d");
        document.body.appendChild(canvas);
        bola.configurar(1);

        var repintar = function() {
            atualizar();
            desenhar();
            window.requestAnimationFrame(repintar, canvas);
        };

        window.requestAnimationFrame(repintar, canvas);
    }

    function atualizar() {
        bola.atualizar();
        jogador1.atualizar();
        ai.atualizar();
    }


    function desenhar(){
        ctx.fillRect(0, 0, LARGURA, ALTURA);

        //entender melhor como funciona essa bagaça...
        ctx.save();

        ctx.fillStyle = "#fff";

        jogador1.desenhar();
        ai.desenhar();
        bola.desenhar();

        //Definindo uma variável para dizer qual o tamanho da largura da linha
        var larguraLinha = 4;
        //Definindo outra variável para dizer qual será a posição X da linha, que no caso, como eu quero colocar no meio do campo, seria a “largura do campo” menos a “largura da linha” divido por 2
        var x = (LARGURA - larguraLinha) / 2;
        //Definindo outra variável para dizer a posição Y a partir de onde será desenhado o tracejado
        var y = 0;
        //aqui estamos definindo outra variável para dizer qual será a  distância entre um traço e outro
        var passo = ALTURA/20; // how many net segments
        while (y < ALTURA) {
            //"x" define a posição X do retângulo, y diz a posição Y do retângulo, estamos somando com passo / 4 pois queremos que ele fique no começo da tela com um espaço de 1/4 sem estar pintado. A "larguraLinha" diz a largura do retângulo, e o passo / 2 é que queremos que o tamanho vertical dele sejá igual a metade (1/2) do passo.
            ctx.fillRect(x, y + passo / 4, larguraLinha, passo / 2);
            y += passo;
        }

        //entender melhor como funciona essa bagaça...
        ctx.restore();
        //createAndSendDocument();        
    }
	
	//**************************\\
	
    var reqAnimationFrame = (function () {
        return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    })();

    var el = document.querySelector("#hit");
	var onEnd = false;

    var START_X = 0; 
    var START_Y = POS_INI_Y;

    var ticking = false;
    var transform;

    var mc = new Hammer.Manager(el);

    mc.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));

	mc.on("panmove", onPan);
	mc.on("panend", onPanEnd);

    function resetElement() {
		var hit = document.getElementById("hit");
		el.style.width = jogador1.largura + 'px';
		el.style.height = jogador1.altura + 'px';
		transform = {
			translate: { x: START_X, y: START_Y },
			scale: 1,
			angle: 0,
			rx: 0,
			ry: 0,
			rz: 0
		};
        requestElementUpdate();
    }

    function updateElementTransform() {
        var value = [
                    'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)'
        ];
        el.style.transform = value;
        ticking = false;
    }

    function requestElementUpdate() {
        if(!ticking) {
            reqAnimationFrame(updateElementTransform);
            ticking = true;
        }
    }
	
    function onPan(ev) {
        el.className = '';
		transform.translate = {
			x: 0 + START_X,
			y: ev.deltaY + START_Y
		};
		jogador1.y = transform.translate.y;
        requestElementUpdate();
    }
	
	function onPanEnd(ev) { 
		START_X = transform.translate.x;
		START_Y = transform.translate.y;
		onEnd = true;
	}
	
	resetElement();
	
    main();
    </script>
</body>
</html>